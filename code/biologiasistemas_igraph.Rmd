---
title: "biologiasistemas_igrapgh"
author: "Maria Vida Montañez y María José Hidalgo Rodríguez"
date: "2023-11-18"
output: html_document
---

## Propiedades de la red

```{r}
# Importamos libreria
library(igraph)
# Cargamos los datos
genes <- read.table("../results/genes_igraph.txt", sep = '\t', header = FALSE, stringsAsFactors = FALSE)
#Creamos un nuevo grafo no dirigido a partir de esta información
net <- graph_from_data_frame(genes, directed=F)
```

```{r}
# Mostramos la red
par(cex = 0.4)
plot(net)
```

```{r}
# Comprobamos que no hay ningun nodo sin conexión.
is.connected(net)
```

```{r}
# Comprobamos que no es dirigido
is.directed(net)
```

```{r}
# Grado centralidad: numero de conexiones de cada gen
degree_centrality <- degree(net)
# Creamos el dataframe con los resultados
result_df <- data.frame(Gene = names(degree_centrality), Degree_Centrality = degree_centrality)
# Imprimimos resultados
print(result_df)
# Guardamos los resultados
write.table(result_df, file = "../results/degree_centrality_results.txt", sep = "\t", quote = FALSE, row.names = FALSE)
```

```{r}
# Centralidad de cercanía: Mide la distancia promedio entre un nodo y todos los demás nodos
closeness_centrality <- closeness(net)
closeness_centrality
```

```{r}
# Conectividad:Mide la fortaleza de la conexión en el grafo.
connectivity <- edge_density(net)
connectivity
```

## Identificacion de comunidades

```{r}
#  Detección de comunidades mediante in_betweeness.
community <- cluster_edge_betweenness(net)
dendPlot(community, mode="hclust")
# Mostramos el grafo con las clusters detectados
par(cex = 0.4)
plot(community, net)
# Guardamos la imagen en la carpeta results
dev.copy(png, filename = "../results/clustering_in_betweeness.png", width = 800, height = 600)  
dev.off()
```

Metodo de Girvan-Newman. Este método, basado en la centralidad de intermediación (betweenness), busca identificar comunidades cortando enlaces que conectan las partes más densas de la red. Hay nodos que no pertenecen a ninguna comunidad. Esto puede deberse a la forma en que el algoritmo de betweenness identifica comunidades. Puede detectar comunidades basándose en la centralidad de intermediación de los nodos, y algunos nodos pueden no estar claramente vinculados a una comunidad en función de esta medida.

```{r}
# Detección de comunidades mediante optimización voraz. Este enfoque busca la modularidad de la red
cfg <- cluster_fast_greedy(as.undirected(net))
par(cex = 0.4)
plot(cfg, as.undirected(net))
# Guardamos la imagen en la carpeta results
dev.copy(png, filename = "../results/clustering_fast_greedy.png", width = 800, height = 600)  
dev.off()
```

Podemos ver que con este tipo de metodo todos los nodos pertenecen a alguna comunidad. El algoritmo de optimización voraz busca maximizar la modularidad de la red, dividiéndola en comunidades más densamente conectadas internamente.

```{r}
# Pinta el grafo de manera que los nodos que lo forman compartan un mismo color si pertenecen a la misma comunidad.
V(net)$community <- cfg$membership
colrs <- adjustcolor( c("gray50", "tomato", "gold", "yellowgreen", "blue"), alpha=.6)
par(cex = 0.4)
plot(net, vertex.color=colrs[V(net)$community])
# Guardamos la imagen en la carpeta results
dev.copy(png, filename = "../results/clustering_coloreado.png", width = 800, height = 600)  
dev.off()
```

```{r}
# Detección de comunidades mediante propagación de etiquetas.
clp <- cluster_label_prop(net)
par(cex = 0.4)
plot(clp, net)
# Guardamos la imagen en la carpeta results
dev.copy(png, filename = "../results/clustering_label_prop.png", width = 800, height = 600)  
dev.off()
```

En este caso solo ha identificado a dos comunidades. La propagación de etiquetas es un enfoque basado en la difusión de información a través de la red. Puede ocurrir que esta técnica agrupe nodos que están fuertemente conectados, pero puede no ser tan sensible a las sutilezas de la modularidad como otros algoritmos.

```{r}
community_louvain <- cluster_louvain(net)
par(cex = 0.4)
plot(community_louvain, net)
# Guardamos la imagen en la carpeta results
dev.copy(png, filename = "../results/clustering_louvain.png", width = 800, height = 600)  
dev.off()
```

El algoritmo de Louvain es muy popular y eficiente. Este método busca maximizar la modularidad de la red y es conocido por su velocidad en comparación con algunos otros algoritmos. En este caso hemos obtenido 4 comunidades en vez de 5.

```{r}
library(linkcomm)

lg <- swiss[,3:4]
lc <- getLinkCommunities(genes)


```

En las graficas anteriores vemos como las comunidades se solapaban, lo que no podia indicar que hay nodos que pueden pertenecer a mas de una comunidad. Para estudiar este hecho vamos a hacer uso de Link Communites.

```{r}
# Visualiza las link communities
options(repr.plot.width=9, repr.plot.height=9)
par(cex = 0.5)
plot(lc, type = "graph", layout = "spencer.circle")
# Guardamos la imagen en la carpeta results
dev.copy(png, filename = "../results/clustering_link_communities.png", width = 800, height = 600)  
dev.off()
```

## Estudio genes de interes

Comparamos las relaciones establecidas con strindb en funcion de las enfermedades con la tabla que obtenemos a continuacion.

```{r}
# Genes de interés
genes_interes <- c("TP53", "HRAS", "AKT1", "SDHB", "SDHD")

# Función para encontrar vecinos interesantes
encontrar_vecinos_interesantes <- function(gen, genes_interes) {
  vecinos <- neighbors(net, gen)$name
  vecinos_interesantes <- vecinos[vecinos %in% genes_interes]
  return(paste(vecinos_interesantes, collapse = ", "))
}

# Crear la tabla
tabla_genes <- data.frame(Gen = genes_interes)

# Agregar la columna de vecinos interesantes como cadenas de texto
tabla_genes$Vecinos_Interesantes <- sapply(genes_interes, function(gen) {
  encontrar_vecinos_interesantes(gen, genes_interes)
})

# Imprimir la tabla
print(tabla_genes)

# Guardamos los resultados
write.table(tabla_genes, file = "../results/tabla_genes.csv", sep = "\t", quote = FALSE, row.names = FALSE)
```

## Enriquecimiento

```{r}
# Instala el paquete si aún no lo has hecho
if (!requireNamespace("enrichR", quietly = TRUE))
  install.packages("enrichR")

if (!requireNamespace("reshape2", quietly = TRUE))
  install.packages("reshape2")

# Carga la librería
library(enrichR)

# Obtener la pertenencia del nodo a cada cluster
membership <- membership(cfg)

# Iterar sobre cada cluster
for (i in unique(membership)) {
  # Obtener los nodos pertenecientes al cluster actual
  nodes_in_cluster <- which(membership == i)
  
  # Obtener los nombres de genes en el cluster
  genes_in_cluster <- names(nodes_in_cluster)
  
  # Realizar enriquecimiento funcional con enrichR (usando la base de datos GO como ejemplo)
  enrich_result <- enrichr(genes = genes_in_cluster, c("GO_Biological_Process_2021"))
  
  # Imprimir resultados o hacer cualquier otro procesamiento
  cat("Enriquecimiento funcional para el Cluster", i, ":\n")
  print(enrich_result)
  
  # Generar un nombre de archivo único para cada cluster
  file_name <- paste0("enrichment_cluster_", i, ".csv")
  
  # Guardar los resultados en un archivo CSV
  write.table(enrich_result, file = file_name, sep = ",", quote = FALSE, col.names = TRUE, row.names = FALSE)
}


```
