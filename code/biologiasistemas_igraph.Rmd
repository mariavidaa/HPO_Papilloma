---
title: "biologiasistemas_igrapgh"
author: "Maria Vida Montañez"
date: "2023-11-18"
output: html_document
---

## Propiedades de la red

```{r}
# Importamos libreria
library(igraph)
# Cargamos los datos
genes <- read.table('./genes_igraph.txt', sep='\t', header=FALSE, stringsAsFactors=FALSE)
#Creamos un nuevo grafo no dirigido a partir de esta información
net <- graph_from_data_frame(genes, directed=F)
```

```{r}
# Mostramos la red
par(cex = 0.4)
plot(net)
```

```{r}
# Comprobamos que no hay ningun nodo sin conexión.
is.connected(net)
```
```{r}
# Comprobamos que no es dirigido
is.directed(net)
```
```{r}
# Grado centralidad: numero de conexiones de cada gen
degree_centrality <- degree(net)
degree_centrality
```
```{r}
# Centralidad de cercanía: Mide la distancia promedio entre un nodo y todos los demás nodos
closeness_centrality <- closeness(net)
closeness_centrality
```
```{r}
# Conectividad:Mide la fortaleza de la conexión en el grafo.
connectivity <- edge_density(net)
connectivity
```

## Identificacion de comunidades

```{r}
#  Detección de comunidades mediante in_betweeness.
community <- cluster_edge_betweenness(net)
dendPlot(community, mode="hclust")
# Mostramos el grafo con las clusters detectados
par(cex = 0.4)
plot(community, net)
```
Metodo de Girvan-Newman. Este método, basado en la centralidad de intermediación (betweenness), busca identificar comunidades cortando enlaces que conectan las partes más densas de la red. Hay nodos que no pertenecen a ninguna comunidad. Esto puede deberse a la forma en que el algoritmo de betweenness identifica comunidades. Puede detectar comunidades basándose en la centralidad de intermediación de los nodos, y algunos nodos pueden no estar claramente vinculados a una comunidad en función de esta medida.

```{r}
# Detección de comunidades mediante optimización voraz. Este enfoque busca la modularidad de la red
cfg <- cluster_fast_greedy(as.undirected(net))
par(cex = 0.4)
plot(cfg, as.undirected(net))
```
Podemos ver que con este tipo de metodo todos los nodos pertenecen a alguna comunidad. El algoritmo de optimización voraz busca maximizar la modularidad de la red, dividiéndola en comunidades más densamente conectadas internamente.

```{r}
# Pinta el grafo de manera que los nodos que lo forman compartan un mismo color si pertenecen a la misma comunidad.
V(net)$community <- cfg$membership
colrs <- adjustcolor( c("gray50", "tomato", "gold", "yellowgreen", "blue"), alpha=.6)
par(cex = 0.4)
plot(net, vertex.color=colrs[V(net)$community])
```

```{r}
# Detección de comunidades mediante propagación de etiquetas.
clp <- cluster_label_prop(net)
par(cex = 0.4)
plot(clp, net)
```
En este caso solo ha identificado a dos comunidades. La propagación de etiquetas es un enfoque basado en la difusión de información a través de la red. Puede ocurrir que esta técnica agrupe nodos que están fuertemente conectados, pero puede no ser tan sensible a las sutilezas de la modularidad como otros algoritmos.

```{r}
community_louvain <- cluster_louvain(net)
par(cex = 0.4)
plot(community_louvain, net)
```

El algoritmo de Louvain es muy popular y eficiente. Este método busca maximizar la modularidad de la red y es conocido por su velocidad en comparación con algunos otros algoritmos. En este caso hemos obtenido 4 comunidades en vez de 5. 

```{r}
library(linkcomm)

lg <- swiss[,3:4]
lc <- getLinkCommunities(genes)


```


En las graficas anteriores vemos como las comunidades se solapaban, lo que no podia indicar que hay nodos que pueden pertenecer a mas de una comunidad. Para estudiar este hecho vamos a hacer uso de Link Communites. 

```{r}
# Visualiza las link communities
options(repr.plot.width=9, repr.plot.height=9)
par(cex = 0.5)
plot(lc, type = "graph", layout = "spencer.circle")

```

