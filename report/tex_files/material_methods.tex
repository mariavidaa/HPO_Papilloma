\section{Materiales y métodos}

\subsection{Materiales}

\subsection{Métodos}
En primer lugar creamos una función que busca genes asociados a un fenotipo específico utilizando la API de \textbf{HPO}.
La función recibe el parámetro fenotipo, que es el código HPO para el fenotipo de interés.
Realizamos una solicitud GET a la API de HPO para obtener información sobre genes asociados al fenotipo.
Si la solicitud es exitosa (código de estado 200), extraemos y devolvemos los genes asociados al fenotipo. Si no, imprimimos un mensaje de error y devolvemos una lista vacía.


Utilizamos la función $buscar\_genes\_por\_fenotipo$ para obtener los genes asociados al fenotipo "Papilloma" (código HPO: HP:0012740).
Si encontramos genes asociados, imprimimos los nombres de los genes. Si no encontramos genes asociados, mostramos un mensaje indicando que no se encontraron genes.

Tras esto construimos una URL con los símbolos de los genes obtenidos anteriormente para realizar una solicitud a la API de StringDB, que proporciona información sobre interacciones de proteínas.
Realizamos una solicitud GET a la API de StringDB para obtener una red de interacciones de proteínas.
Guardamos la respuesta como una imagen llamada 'img.png'.

Imprimimos y filtramos los resultados del análisis de enriquecimiento por categorías ('Process' y 'KEGG').
Realizamos búsquedas específicas en los resultados de enfermedades y genes utilizando palabras clave y patrones de genes relevantes, respectivamente.
Guardamos los resultados de las búsquedas en archivos CSV .

Realizamos una solicitud GET a la API de StringDB para descargar la red de interacciones en formato TSV.
Si la descarga es exitosa, guardamos el archivo con el nombre proporcionado por la respuesta o como $'red_descargada.tsv'$ si no se obtiene un nombre de archivo.
Si hay un error en la descarga, imprimimos un mensaje de error.

Cargamos el archivo TSV descargado.
Seleccionamos columnas específicas ($'preferredName_A'$ y $'preferredName_B'$) y eliminamos duplicados.
Guardamos estas columnas en un nuevo archivo de texto llamado $'genes_igraph.txt'$.

Nosotros usamos la biblioteca de \textbf{igraph} disponible en el lenguaje de programación de R para realizar el análisis y la visualización de la red. En primer lugar, importamos la librería y leímos el fichero que obtuvimos al generar la red con la API de STRINGDB y la guardamos en un grafo. A partir de este, estudiamos las \textbf{propiedades del grafo}, si todos los nodos estaban conectados con la función isconnected(), si era o no dirigido con la función is.directed(), el grado de centralidad que nos informaba del número de conexiones de cada gen con la función degree(), la centralidad de cercanía con la que obtuvimos la distancia promedio entre un nodo y todos los demás nodos mediante la aplicación de closeness(), y la conectividad que nos indicaba la fortaleza de la conexión del nodo aplicando $edge\_density()$. 

\vspace{3pt}

En segundo lugar, llevamos a cabo la \textbf{identificación de comunidades} mediante distintos \textbf{algoritmos de clusterización}: método de Girvan-Newman, algoritmo de optimización voraz, propagación de etiquetas y el algoritmo de Louvain. 

\vspace{3pt}
\begin{enumerate}
\item El método de \textbf{Girvan Newman} detecta comunidades basándose en la centralidad de intermediación de los nodos, en otras palabras, va eliminando gradualmente las aristas más importantes para identificar las comunidades de la red \cite{Zahiri2023}.


\item El \textbf{algoritmo voraz}, busca formar grupos de datos de manera iterativa tomando en cada paso la elección más beneficiosa para fusionar o dividir clusters con el objetivo de maximizar un criterio local \cite{Curtis2003}. 


\item La \textbf{propagación de etiquetas} es un enfoque basado en la difusión de información a través de la red que agrupa los nodos que están fuertemente conectados \cite{Garza2019}.

\item Por último el \textbf{algoritmo de Louvain} busca organizar los nodos de una red en comunidades de manera que la modularidad global de la red sea máxima, o en otras palabras, cómo de bien se dividen los nodos de una red en grupos o comunidades distintas \cite{Zhang2021}.

\end{enumerate}

\vspace{3pt}

Para estudiar mejor a qué comunidad pertenece cada nodo, visualizamos el resultado de la aplicación del algoritmo de Louvain mediante la aplicación de \textbf{link communities} que nos permitía identificar si alguno de los nodos se incluían en varias comunidades. 

\vspace{3pt}

En tercer lugar, estudiamos la interacción de nuestros \textbf{genes de interés} especificados anteriormente: TP53, HRAS, AKT1, SDHB, SDHD. Para ellos creamos una función que nos devolvía una tabla con los vecinos de cada uno de estos genes para saber si entre ellos estaban relacionados.

\vspace{3pt}

En último lugar, tras estudiar la detección de comunidades optamos por realizar un enriquecimiento funcional para la comunidad identificada donde se encuentren nuestros genes de interés. Para ello, hemos guardado los genes que conforman la comunidad donde se encuentran los genes de interés en un archivo y hemos realizado un enriquecimiento funcional de estos genes filtrando para quedarnos con las entradas de categoría HPO \cite{hpojax} (para relacionar estos genes con fenotipos patológicos).  Estos datos se guardan en un archivo de extensión csv y hemos consultado las entradas de este buscando por palabras clave (papilloma, genital, renal, carcinoma, ovarian, ovary, ovaries, uterine). 


